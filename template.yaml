apiVersion: scaffolder.backstage.io/v1beta3
kind: Template
metadata:
  name: Github-pages-deploy-from-github
  title: Deploy to Github pages from GitHub Repo
  description: Create and deploy a Docker container from a GitHub repository URL.
spec:
  owner: user:guest
  type: service

  
  parameters:
    - title: GitHub Repository URL
      required: 
        - Github_URL
        #- Dockerfile
        #- Port
      properties:
        Github_URL:
          title: Enter you Github URL
          type: string
          description: Enter the github URL where your code exists
          ui:autofocus: true

    - title: Select where you want to deploy your code
      required:
        - stack
      properties:
        stack:
          title: Select from below list
          type: string
          enum:
            - Docker
            - Github pages
            - Baremetal
            - Kubernetes
  
    - title: Enter below details
      dependencies:
        stack:
          oneOf:
            - properties:
                stack:
                  const: Docker
                extraFields:          # üëà wrap everything else inside a schema key
                  title: Enter the details
                  type: object
                  properties:
                    Dockerfile:
                      title: Enter the Path of Dockerfile
                      type: string
                      description: Enter the Dockerfile path (e.g. build/Dockerfile or enter Dockerfile if it is in root) 
                      default: "Dockerfile" 
                    Port:
                      title: Enter the Port number
                      type: integer
                      minimum: 1
                      maximum: 65535
                      description: Enter the Port number of your application (e.g. 80/3000/5000)
  
            - properties:
                stack:
                  const: Github pages
                extraFields:
                  type: object
                  properties: 
                    # Github:
                    #   title: Enter the Path of Github Url
                    #   type: string
                    #   description: Enter the Github URL 
                      
                      
                    GithubToken:
                      title: Enter the Github Token
                      type: string
                      description: Enter the token
                       
  
            - properties:
                stack:
                  const: Baremetal
                extraFields:
                  type: object
                  properties: {}
            
            - properties:
                stack:
                  const: Kubernetes
                extraFields:
                  title: Kubernetes Deployment Details
                  type: object
                  properties:
                    DeploymentFile:
                      title: Deployment Manifest Path
                      type: string
                      description: Path to your deployment YAML file (relative to repo)
                      default: "deployment.yaml"
                    ServiceFile:
                      title: Service Manifest Path
                      type: string
                      description: Path to your service YAML file (relative to repo)
                      default: "service.yaml"
                    Namespace:
                      title: Kubernetes Namespace (optional)
                      type: string
                      description: Namespace to deploy into (leave blank for default)
                      default: "default"
          
  steps:


    - id: fetch
      name: Fetch GitHub Repo
      action: fetch:plain
      input:
        url: ${{ parameters.Github_URL }}
        targetPath: ./site  # fetch code into ./site folder

    - id: fetch-kube
      name: Fetch Kubernetes Manifests
      if: ${{ parameters.stack == 'Kubernetes' }}
      action: fetch:plain
      input:
        url: ${{ parameters.Github_URL }}
        targetPath: ./kube
        
    - id: apply-kube
      name: Deploy to Kubernetes via Minikube
      if: ${{ parameters.stack == 'Kubernetes' }}
      action: shell:run
      input:
        cwd: ./kube
        command: bash
        args:
          - -c
          - |
            set -euo pipefail

            echo "üöÄ Starting Kubernetes deploy step..."

            # parameters from template
            NAMESPACE="${{ parameters.extraFields.Namespace }}"
            DEPLOY="${{ parameters.extraFields.DeploymentFile }}"
            SERVICE="${{ parameters.extraFields.ServiceFile }}"

            # defaults
            if [[ -z "$NAMESPACE" ]]; then
              NAMESPACE="default"
            fi

            echo "üìÅ Using working dir: $(pwd)"
            echo "üì¶ Deployment file: $DEPLOY"
            echo "üîß Service file:    $SERVICE"
            echo "üìÇ Namespace:       $NAMESPACE"

            # ensure files exist (fail early with clear message)
            if [[ ! -f "$DEPLOY" ]]; then
              echo "ERROR: Deployment file not found at ./kube/$DEPLOY" >&2
              exit 5
            fi
            if [[ ! -f "$SERVICE" ]]; then
              echo "ERROR: Service file not found at ./kube/$SERVICE" >&2
              exit 6
            fi

            # ensure kubectl exists
            if ! command -v kubectl >/dev/null 2>&1; then
              echo "ERROR: kubectl not found on runner" >&2
              exit 7
            fi

            # Minikube optional check (not mandatory for non-minikube clusters)
            if ! command -v minikube >/dev/null 2>&1; then
              echo "WARN: minikube not found; nodePort external URL may not be resolvable from host"
            fi

            # create namespace if needed
            kubectl get ns "$NAMESPACE" >/dev/null 2>&1 || kubectl create ns "$NAMESPACE"

            # apply manifests
            echo "Applying deployment..."
            kubectl apply -f "$DEPLOY" -n "$NAMESPACE"

            echo "Applying service..."
            kubectl apply -f "$SERVICE" -n "$NAMESPACE"

            echo "Waiting a short while for resources..."
            sleep 3

            # determine service name (best-effort: read name from service yaml)
            SVC_NAME=$(kubectl get -f "$SERVICE" -n "$NAMESPACE" -o jsonpath='{.metadata.name}' 2>/dev/null || true)
            if [[ -z "$SVC_NAME" ]]; then
              # fallback: pick the most recently created service in namespace
              SVC_NAME=$(kubectl get svc -n "$NAMESPACE" --sort-by=.metadata.creationTimestamp -o jsonpath='{.items[-1].metadata.name}')
            fi

            if [[ -z "$SVC_NAME" ]]; then
              echo "ERROR: Could not determine service name" >&2
              exit 8
            fi

            echo "Detected service name: $SVC_NAME"

            # try to get nodePort first (exposed externally)
            NODE_PORT=$(kubectl get svc "$SVC_NAME" -n "$NAMESPACE" -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || true)
            CLUSTER_PORT=$(kubectl get svc "$SVC_NAME" -n "$NAMESPACE" -o jsonpath='{.spec.ports[0].port}' 2>/dev/null || true)
            CLUSTER_IP=$(kubectl get svc "$SVC_NAME" -n "$NAMESPACE" -o jsonpath='{.spec.clusterIP}' 2>/dev/null || true)

            # decide which external URL to provide:
            if [[ -n "$NODE_PORT" && -n "$(command -v minikube 2>/dev/null)" ]]; then
              MINIKUBE_IP=$(minikube ip 2>/dev/null || true)
              if [[ -n "$MINIKUBE_IP" ]]; then
                EXTERNAL_URL="http://$MINIKUBE_IP:$NODE_PORT"
              else
                EXTERNAL_URL=""
              fi
            else
              # fallback to ClusterIP:port (internal cluster URL)
              if [[ -n "$CLUSTER_IP" && -n "$CLUSTER_PORT" ]]; then
                EXTERNAL_URL="http://$CLUSTER_IP:$CLUSTER_PORT"
              else
                EXTERNAL_URL=""
              fi
            fi

            echo "Service details: name=$SVC_NAME, clusterIP=$CLUSTER_IP, port=$CLUSTER_PORT, nodePort=$NODE_PORT"
            if [[ -n "$EXTERNAL_URL" ]]; then
              echo "Service reachable at: $EXTERNAL_URL"
            else
              echo "No external URL could be determined (service may be ClusterIP-only and not accessible from host)"
            fi

            # Create output.json that Backstage will read
            echo "{\"service_name\": \"$SVC_NAME\", \"cluster_ip\": \"$CLUSTER_IP\", \"port\": \"$CLUSTER_PORT\", \"node_port\": \"$NODE_PORT\", \"external_url\": \"$EXTERNAL_URL\"}" > output.json

      output:
        service_name: ${{ steps.apply-kube.output.service_name }}
        cluster_ip: ${{ steps.apply-kube.output.cluster_ip }}
        port: ${{ steps.apply-kube.output.port }}
        node_port: ${{ steps.apply-kube.output.node_port }}
        external_url: ${{ steps.apply-kube.output.external_url }}


      output:
        service_name: ${{ steps.apply-kube.output.service_name }}
        external_url: ${{ steps.apply-kube.output.external_url }}
    # - id: apply-kube
    #   name: Deploy to Kubernetes via Minikube
    #   if: ${{ parameters.stack == 'Kubernetes' }}
    #   action: shell:run
    #   input:
    #     cwd: ./kube
    #     command: bash
    #     args:
    #       - -c
    #       - |
    #         set -e
    #         echo "üöÄ Applying manifests to Minikube cluster..."

    #         NAMESPACE="${{ parameters.extraFields.Namespace }}"
    #         DEPLOY="${{ parameters.extraFields.DeploymentFile }}"
    #         SERVICE="${{ parameters.extraFields.ServiceFile }}"

    #         echo "üìÅ Using namespace: $NAMESPACE"
    #         kubectl get ns "$NAMESPACE" >/dev/null 2>&1 || kubectl create ns "$NAMESPACE"

    #         echo "üì¶ Applying deployment..."
    #         kubectl apply -f "$DEPLOY" -n "$NAMESPACE"

    #         echo "üîß Applying service..."
    #         kubectl apply -f "$SERVICE" -n "$NAMESPACE"

    #         echo "‚úÖ Deployment and Service applied successfully!"
    #         SVC_NAME=$(kubectl get svc -n "$NAMESPACE" -o jsonpath='{.items[0].metadata.name}')
    #         CLUSTER_IP=$(kubectl get svc "$SVC_NAME" -n "$NAMESPACE" -o jsonpath='{.spec.clusterIP}')
    #         PORT=$(kubectl get svc "$SVC_NAME" -n "$NAMESPACE" -o jsonpath='{.spec.ports[0].port}')

    #         echo "üåç Service available at: $SVC_URL"


    #         echo "::set-output name=serviceName::$SVC_NAME"
    #         echo "::set-output name=clusterIp::$CLUSTER_IP"
    #         echo "::set-output name=servicePort::$PORT"
    #         NODE_PORT=$(kubectl get svc "$SVC_NAME" -n "$NAMESPACE" -o jsonpath='{.spec.ports[0].nodePort}')
    #         MINIKUBE_IP=$(minikube ip)
    #         echo "::set-output name=externalUrl::http://$MINIKUBE_IP:$NODE_PORT"

    #         echo "service_name=$SVC_NAME" >> $GITHUB_OUTPUT
    #         echo "external_url=http://$MINIKUBE_IP:$NODE_PORT" >> $GITHUB_OUTPUT
        
      # output:
      #   service_name: ${{ steps.apply-kube.output.service_name }}
      #   external_url: ${{ steps.apply-kube.output.external_url }}
    # - id: fetch-kube
    #   name: Fetch Kubernetes Manifests
    #   if: ${{ parameters.stack == 'Kubernetes' }}
    #   action: fetch:plain
    #   input:
    #     url: ${{ parameters.Github_URL }}
    #     targetPath: ./kube

    # - id: apply-kube
    #   name: Deploy to Kubernetes via Minikube
    #   if: ${{ parameters.stack == 'Kubernetes' }}
    #   action: shell:run
    #   input:
    #     cwd: ./kube
    #     command: bash
    #     args:
    #       - -c
    #       - |
    #         set -e
    #         echo "üöÄ Applying manifests to Minikube cluster..."

    #         NAMESPACE="${{ parameters.extraFields.Namespace }}"
    #         DEPLOY="${{ parameters.extraFields.DeploymentFile }}"
    #         SERVICE="${{ parameters.extraFields.ServiceFile }}"

    #         echo "Using namespace: $NAMESPACE"
    #         kubectl apply -f "$DEPLOY" -n "$NAMESPACE"
    #         kubectl apply -f "$SERVICE" -n "$NAMESPACE"

    #         echo "‚úÖ Deployed successfully!"
    #         echo "üåê Fetching service URL..."
    #         minikube service --url -n "$NAMESPACE" $(kubectl get svc -n "$NAMESPACE" -o jsonpath='{.items[0].metadata.name}') || true

  output:
    links:
      - title: "Open Website"
        if: ${{ parameters.stack == 'Kubernetes' }}
        url: "${{ steps.apply-kube.output.externalUrl }}"
        icon: "website"
  # output:
  #   serviceName: ${{ steps.apply-kube.output.serviceName }}
  #   serviceUrl: ${{ steps.apply-kube.output.serviceUrl }}

  #   links:
  #     - title: "üåç Open Deployed Website"
  #       if: ${{ parameters.stack == 'Kubernetes' }}
  #       url: ${{ output.serviceUrl }}
  #       icon: "website"
  
  #     - title: "üîß View Kubernetes Service in API Proxy"
  #       if: ${{ parameters.stack == 'Kubernetes' }}
  #       url: "http://localhost:8001/api/v1/namespaces/${{ parameters.extraFields.Namespace }}/services/${{ output.serviceName }}/proxy/"
  #       icon: "kubernetes"
      
   # output:
   #   links:
  #     # - title: "View on GitHub Pages"
  #     #   #if: "${{ parameters.deploy_method == 'github pages' }}"
  #     #   # if: "${{ parameters.stack == 'Github pages' }}"
  #     #   url: "https://${{ parameters.Github_URL | replace('https://github.com/', '') | replace('.git', '') | replace('/', '.github.io/') }}/"
  #     #   #url: ${{ steps.github-pages.output.pageUrl }}
  #     #   icon: "website"

        
  #     - title: "Open Kubernetes Service"
  #       if: ${{ parameters.stack == 'Kubernetes' }}
  #       url: "Output will show Minikube service URL above"
  #       icon: "server"

        
